generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* =========================
   GLOBAL ENUMS
   ========================= */

enum Role {
  USER
  ADMIN
}

enum EventFormat {
  SINGLE_ELIM
  // Future: DOUBLE_ELIM, ROUND_ROBIN, SWISS, etc.
}

enum MatchStatus {
  PENDING
  SCHEDULED
  REPORTED
  VERIFIED
  CANCELED
}

enum EventRole {
  OWNER
  ORGANIZER
}

enum ReportStatus {
  PENDING
  APPROVED
  REJECTED
}

/* =========================
   USERS
   ========================= */

model User {
  id       Int    @id @default(autoincrement())
  email    String @unique
  password String
  role     Role   @default(USER)

  participants    Participant[]
  teamMemberships TeamMember[]
  eventRoles      EventRoleAssignment[]
}

/* =========================
   TOURNAMENTS / EVENTS
   ========================= */

model Tournament {
  id              Int          @id @default(autoincrement())
  name            String
  game            String
  format          EventFormat  @default(SINGLE_ELIM)
  isTeamBased     Boolean      @default(true)  // true = team events, false = individual

  startDate       DateTime
  endDate         DateTime?
  status          String       @default("upcoming") // upcoming, ongoing, completed

  maxParticipants Int?
  location        String?      // free-form location text

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  matches         Match[]
  teams           Team[]
  participants    Participant[]
  staff           EventRoleAssignment[]
}

/* =========================
   TEAMS & MEMBERS
   ========================= */

model Team {
  id           Int          @id @default(autoincrement())
  tournamentId Int
  name         String
  tag          String?

  tournament   Tournament   @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  members      TeamMember[]
  participants Participant[]

  createdAt    DateTime     @default(now())

  @@unique([tournamentId, name])
}

model TeamMember {
  id        Int    @id @default(autoincrement())
  teamId    Int
  userId    Int
  isCaptain Boolean @default(false)

  team      Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User   @relation(fields: [userId], references: [id])

  @@unique([teamId, userId])
}

/* =========================
   PARTICIPANTS (ENTRY IN EVENT)
   ========================= */

model Participant {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  userId       Int?       // filled for individual events
  teamId       Int?       // filled for team events
  seed         Int?
  joinedAt     DateTime   @default(now())

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User?      @relation(fields: [userId], references: [id])
  team         Team?      @relation(fields: [teamId], references: [id])

  matchesAsP1  Match[]    @relation("MatchP1")
  matchesAsP2  Match[]    @relation("MatchP2")
  matchesWon   Match[]    @relation("MatchWinner")

  @@index([tournamentId])
  // App invariant: exactly one of userId or teamId is non-null.
}

/* =========================
   EVENT ROLES (OWNER / ORGANIZER)
   ========================= */

model EventRoleAssignment {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  userId       Int
  role         EventRole

  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id])

  @@unique([tournamentId, userId, role])
}

/* =========================
   MATCHES
   ========================= */

model Match {
  id           Int         @id @default(autoincrement())
  tournamentId Int
  tournament   Tournament  @relation(fields: [tournamentId], references: [id], onDelete: Cascade)

  // Bracket position
  roundNumber  Int?        // 1 = first round, 2 = second round, etc.
  slotIndex    Int?        // position within that round

  // Participants (teams or individuals via Participant)
  p1Id         Int?
  p2Id         Int?
  winnerId     Int?

  p1           Participant? @relation("MatchP1", fields: [p1Id], references: [id])
  p2           Participant? @relation("MatchP2", fields: [p2Id], references: [id])
  winner       Participant? @relation("MatchWinner", fields: [winnerId], references: [id])

  p1Score      Int?
  p2Score      Int?

  scheduledAt  DateTime?
  completedAt  DateTime?
  location     String?      // free-form location text

  status       MatchStatus  @default(PENDING)

  // Optional: bracket wiring for single elim
  nextMatchId  Int?
  nextMatch    Match?       @relation("MatchNext", fields: [nextMatchId], references: [id])
  children     Match[]      @relation("MatchNext")

  createdAt    DateTime     @default(now())

  reports      MatchReport[]

  @@index([tournamentId, roundNumber])
  @@index([tournamentId, status])
}

/* =========================
   MATCH REPORTS
   ========================= */

model MatchReport {
  id                   Int          @id @default(autoincrement())
  matchId              Int
  reportedById         Int          // user who submitted the result
  p1Score              Int
  p2Score              Int
  winnerParticipantId  Int
  status               ReportStatus @default(PENDING)

  createdAt            DateTime     @default(now())
  reviewedAt           DateTime?
  reviewedByRoleId     Int?         // an EventRoleAssignment row

  match                Match        @relation(fields: [matchId], references: [id], onDelete: Cascade)
  reportedBy           User         @relation(fields: [reportedById], references: [id])
  reviewedByRole       EventRoleAssignment? @relation(fields: [reviewedByRoleId], references: [id])
}
