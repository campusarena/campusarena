generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int                   @id @default(autoincrement())
  email               String                @unique
  password            String
  role                Role                  @default(USER)
  name                String                @unique
  eventRoles          EventRoleAssignment[]
  invitationsSent     Invitation[]          @relation("InvitationsSent")
  invitationsReceived Invitation[]          @relation("InvitationsReceived")
  submittedReports    MatchReport[]         @relation("ReportedByUser")
  participants        Participant[]
  teamMemberships     TeamMember[]
  gameRatings         PlayerGameRating[]
}

model Tournament {
  id              Int                   @id @default(autoincrement())
  name            String
  game            String
  supportedGameId Int?
  seedBySkill     Boolean               @default(false)
  startDate       DateTime
  endDate         DateTime?
  status          String                @default("upcoming")
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  format          EventFormat           @default(SINGLE_ELIM)
  isTeamBased     Boolean               @default(true)
  location        String?
  maxParticipants Int?
  visibility      TournamentVisibility  @default(PRIVATE)
  autoBracket     Boolean               @default(false)
  staff           EventRoleAssignment[]
  Invitation      Invitation[]
  matches         Match[]
  participants    Participant[]
  teams           Team[]

  supportedGame   Game?                 @relation(fields: [supportedGameId], references: [id], onDelete: SetNull)
}

model Game {
  id         Int          @id @default(autoincrement())
  key        String       @unique
  name       String
  active     Boolean      @default(true)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  tournaments Tournament[]
  ratings    PlayerGameRating[]
}

model PlayerGameRating {
  id          Int      @id @default(autoincrement())
  userId      Int
  gameId      Int
  rating      Int      @default(1500)
  gamesPlayed Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@unique([userId, gameId])
  @@index([gameId])
}

model Team {
  id           Int           @id @default(autoincrement())
  name         String
  tournamentId Int
  createdAt    DateTime      @default(now())
  tag          String?
  participants Participant[]
  tournament   Tournament    @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  members      TeamMember[]

  @@unique([tournamentId, name])
}

model TeamMember {
  id        Int     @id @default(autoincrement())
  teamId    Int
  userId    Int
  isCaptain Boolean @default(false)
  team      Team    @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id])

  @@unique([teamId, userId])
}

model Participant {
  id           Int        @id @default(autoincrement())
  tournamentId Int
  userId       Int?
  teamId       Int?
  seed         Int?
  joinedAt     DateTime   @default(now())
  checkedIn    Boolean    @default(false)
  matchesAsP1  Match[]    @relation("MatchP1")
  matchesAsP2  Match[]    @relation("MatchP2")
  matchesWon   Match[]    @relation("MatchWinner")
  team         Team?      @relation(fields: [teamId], references: [id])
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User?      @relation(fields: [userId], references: [id])

  @@index([tournamentId])
}

model EventRoleAssignment {
  id              Int           @id @default(autoincrement())
  tournamentId    Int
  userId          Int
  role            EventRole
  tournament      Tournament    @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user            User          @relation(fields: [userId], references: [id])
  reviewedReports MatchReport[] @relation("ReviewedByRole")

  @@unique([tournamentId, userId, role])
}

model Match {
  id           Int           @id @default(autoincrement())
  tournamentId Int
  winnerId     Int?
  scheduledAt  DateTime?
  completedAt  DateTime?
  createdAt    DateTime      @default(now())
  location     String?
  nextMatchId  Int?
  nextMatchSlot MatchSlot?
  loserNextMatchId Int?
  loserNextMatchSlot MatchSlot?
  p1Id         Int?
  p1Score      Int?
  p2Id         Int?
  p2Score      Int?
  roundNumber  Int?
  slotIndex    Int?
  bracket      BracketSide   @default(WINNERS)
  status       MatchStatus   @default(PENDING)
  nextMatch    Match?        @relation("MatchNext", fields: [nextMatchId], references: [id])
  children     Match[]       @relation("MatchNext")
  loserNextMatch Match?      @relation("MatchLoserNext", fields: [loserNextMatchId], references: [id])
  loserChildren  Match[]     @relation("MatchLoserNext")
  p1           Participant?  @relation("MatchP1", fields: [p1Id], references: [id])
  p2           Participant?  @relation("MatchP2", fields: [p2Id], references: [id])
  tournament   Tournament    @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  winner       Participant?  @relation("MatchWinner", fields: [winnerId], references: [id])
  reports      MatchReport[]

  @@index([tournamentId, roundNumber])
  @@index([tournamentId, status])
}

model MatchReport {
  id                  Int                  @id @default(autoincrement())
  matchId             Int
  reportedById        Int
  p1Score             Int
  p2Score             Int
  winnerParticipantId Int
  status              ReportStatus         @default(PENDING)
  createdAt           DateTime             @default(now())
  reviewedAt          DateTime?
  reviewedByRoleId    Int?
  match               Match                @relation(fields: [matchId], references: [id], onDelete: Cascade)
  reportedBy          User                 @relation("ReportedByUser", fields: [reportedById], references: [id])
  reviewedByRole      EventRoleAssignment? @relation("ReviewedByRole", fields: [reviewedByRoleId], references: [id])
}

model Invitation {
  id            Int              @id @default(autoincrement())
  tournamentId  Int
  invitedById   Int
  invitedUserId Int?
  invitedEmail  String
  token         String           @unique
  status        InvitationStatus @default(PENDING)
  createdAt     DateTime         @default(now())
  respondedAt   DateTime?
  invitedBy     User             @relation("InvitationsSent", fields: [invitedById], references: [id])
  invitedUser   User?            @relation("InvitationsReceived", fields: [invitedUserId], references: [id])
  tournament    Tournament       @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
}

enum Role {
  USER
  ADMIN
}

enum EventFormat {
  SINGLE_ELIM
  DOUBLE_ELIM
}

enum MatchSlot {
  P1
  P2
}

enum BracketSide {
  WINNERS
  LOSERS
  FINALS
}

enum MatchStatus {
  PENDING
  SCHEDULED
  REPORTED
  VERIFIED
  CANCELED
  READY
  IN_PROGRESS
  COMPLETE
}

enum EventRole {
  OWNER
  ORGANIZER
}

enum ReportStatus {
  PENDING
  APPROVED
  REJECTED
}

enum TournamentVisibility {
  PUBLIC
  PRIVATE
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}
